langgraph_pin: "b0f14649e0669a6399cb790d23672591a2a52884"
langgraph_pin_date: "2026-02-20"

features:
  - id: "F1"
    title: "Pandas DataFrame/Series msgpack serialization"
    subsystem: serializer
    spec: |
      Add first-class pandas DataFrame and Series serialization to
      JsonPlusSerializer in libs/checkpoint/. Currently these types
      only work with pickle_fallback=True. Implement custom msgpack
      ext type handlers in _msgpack_default() and _msgpack_ext_hook()
      that serialize/deserialize DataFrame and Series without relying
      on pickle. Must preserve dtypes, index, column names, and
      multi-index structures.

  - id: "F2"
    title: "Generic Pydantic v2 type round-trip in checkpoint serde"
    subsystem: serializer
    spec: |
      Extend JsonPlusSerializer to support round-tripping arbitrary
      Pydantic v2 BaseModel subclasses through checkpoint
      serialization/deserialization. Currently only specific known
      types are handled. The serializer should detect BaseModel
      instances, serialize them via model_dump(mode="json"), and
      reconstruct them using model_validate() on deserialization,
      preserving the original type information.

  - id: "F3"
    title: "StrEnum preservation in checkpoint serde"
    subsystem: serializer
    spec: |
      Fix JsonPlusSerializer so that Python StrEnum values survive
      a serialize/deserialize round-trip. Currently StrEnum values
      are downcast to plain strings during serialization. The fix
      should preserve the enum type through the EXT_CONSTRUCTOR
      mechanism so that isinstance() checks and .name/.value
      attributes work correctly after deserialization.

  - id: "F4"
    title: "Nested Enum deserialization fix"
    subsystem: serializer
    spec: |
      Fix deserialization of Enum values that are nested inside
      containers (lists, dicts, dataclass fields) in
      JsonPlusSerializer. Currently top-level Enum values round-trip
      correctly, but when an Enum is a field inside a dataclass or
      nested in a dict/list, it deserializes as a plain string/int.
      The fix should recursively apply enum reconstruction through
      the EXT_CONSTRUCTOR mechanism.

  - id: "F5"
    title: "Reducer metadata ordering dependency"
    subsystem: state
    spec: |
      Fix _is_field_binop() in graph/state.py so that Annotated type
      reducers work regardless of metadata ordering. Currently the
      function only checks meta[-1] for a callable reducer. When the
      reducer is not the last Annotated metadata item (e.g.,
      Annotated[list, operator.add, "description"]), it is silently
      dropped and the field becomes LastValue instead of
      BinaryOperatorAggregate. The fix should scan ALL metadata items
      for a callable with a 2-parameter signature.

  - id: "F6"
    title: "BinaryOperatorAggregate ignores default_factory"
    subsystem: state
    spec: |
      Fix BinaryOperatorAggregate.__init__() in channels/binop.py so
      that dataclass field default_factory values are used as the
      channel's initial value. Currently __init__() always calls
      typ() (e.g., list() = []), ignoring any default or
      default_factory on the dataclass field. The fix should wire
      dataclass defaults through the channel construction pipeline
      so that initial state matches the dataclass definition.

  - id: "F7"
    title: "Nested message detection in stream_mode=messages"
    subsystem: streaming
    spec: |
      Fix _find_and_emit_messages() in pregel/_messages.py so that
      messages nested inside Pydantic models, dataclasses, or
      dict-within-state objects are found and emitted during
      stream_mode="messages" streaming. Currently the function only
      scans two levels: top-level state field values, then one level
      of Sequence. Messages in nested objects are silently dropped.
      The fix should recursively traverse nested structures.

  - id: "F8"
    title: "Input message dedup for nested structures"
    subsystem: streaming
    spec: |
      Fix on_chain_start() in pregel/_messages.py so that messages
      nested in Pydantic models, dataclasses, or dicts within the
      input state are added to the `seen` set for deduplication.
      Currently only top-level and one-level-deep sequence messages
      are tracked. When a node receives nested messages in input and
      returns them flattened in output, they are incorrectly emitted
      as "new" duplicates. The fix should recursively scan input
      structures for message IDs.

feature_assignments:
  explicit:
    agent_1: ["F1", "F5"]
    agent_2: ["F2", "F6"]
    agent_3: ["F3", "F7"]
    agent_4: ["F4", "F8"]
  autonomous: null

correlation_pairs:
  - name: "serializer_new_types"
    feature_a: "F1"
    feature_b: "F2"
    shared: "Both extend _msgpack_default()/_msgpack_ext_hook() in jsonplus.py"
  - name: "serializer_type_preservation"
    feature_a: "F3"
    feature_b: "F4"
    shared: "Both fix EXT_CONSTRUCTOR mechanism in jsonplus.py"
  - name: "state_management"
    feature_a: "F5"
    feature_b: "F6"
    shared: "Both fix channel creation pipeline (state.py -> binop.py)"
  - name: "streaming_messages"
    feature_a: "F7"
    feature_b: "F8"
    shared: "Both fix _messages.py (emission + dedup)"
